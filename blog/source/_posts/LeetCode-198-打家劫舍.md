---
title: LeetCode-198.打家劫舍
date: 2020-04-15 11:48:38
tags: ['LeetCode', 'DP']
categories: 题解
---

看似简单，实则很经典的一道`DP`的题目，跟之前每日一题的[按摩师]([面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/))是一个题。

<!--more-->

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
>
> **示例 1:**
>
> ```
> 输入: [1,2,3,1]
> 输出: 4
> 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> **示例 2:**
>
> ```
> 输入: [2,7,9,3,1]
> 输出: 12
> 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```

由于不可以在相邻的房屋闯入，所以在当前位置 `n` 房屋可盗窃的最大值，要么就是 `n-1` 房屋可盗窃的最大值，要么就是 `n-2` 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值。

可以想到利用`DP`记录此前`DP[n-1]` 与`DP[n-2] + nums[n]`取较大的作为`dp[n]`

可以推倒出动态规划方程: `dp[n] = max{dp[n-1], dp[n - 2] + nums[n]}`

众所周知`DP`问题最关键也最难的也是找到动态规划方程，如何找到动态规划方程我私以为是靠的经验 + 分析。

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> dp(nums.size(), 0);
        for (int i = 0; i < nums.size(); ++i)
            dp[i] = max((i > 1 ? dp[i - 2] : 0) + nums[i], 
                        i > 0 ? dp[i - 1] : 0);
        return dp[nums.size() - 1];
    }
};
```

